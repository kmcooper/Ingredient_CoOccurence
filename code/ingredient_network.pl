#####################################
# Script: 	ingredient_hash.pl
# Author: 	Kate Cooper
# Created: 	March 21, 2019
# Last edited:	April 4, 2019
# Input:	ingredients.tab file from ingredient network R code
# Output: 	an ingredient nodes and edges list (in .sif format)
# Methods:	The purpose of this script is to create a nodes and edges file 
#		(a co-occurring ingredient network)
#		for the file generated from the Open Food Database
# Link:		Placeholder for code and raw data on Github
#####################################
#!/usr/bin/perl

use strict;
use warnings;

#
#Placeholder for the input file to be read from command line
#
my $inputfile = "";
my $netfile = "";

#
#Read in arguments from the command line; if no args, die. 
#
if($#ARGV+1 != 2){
	die "\nERROR! Check command-line arguments.\n
	Usage: perl ingredient_hash.pl ingredient_hash.tab netfile.sif \n
	ingredient_hash.tab 	= the file generated by the R script
	netfile.sif		= the name of the file you want the food network written to 
	\n\n"
}else{
	$inputfile = $ARGV[0];
	$netfile = $ARGV[1];
	print "Received the following file as input:		$inputfile\n";
	print "Received the following file for network output:	$netfile\n";
}


#
#Open the file and read it in
#
my $input = open(IN,$inputfile);
my @foods = <IN>;
close(IN)
	or warn "Error closing input file!\n";
#
# Create a hash and put all ingredients into it, counting how many times they occur
#
my %edge_hash;
my $total_item_count = 0;
my $total_edges = 0;
my $single_ingredient_foods = 0;

#
# Subroutine for when ready to add items to the hash
# Input: an ingredient array (where each ingredient is called an item or $i)
# Return: None
#
sub make_food_subnetwork{
	my @foods = (@_);
	my @sorted_foods = sort @foods;
	my $arrsize = $#sorted_foods;
	for(my $i = 0; $i <= $arrsize; $i++){
		for(my $j = $i+1; $j <= $arrsize; $j++){
			my $node1 = $sorted_foods[$i];	
			my $node2 = $sorted_foods[$j];
			$node1 =~ s/\s/\_/gi;
			$node2 =~ s/\s/\_/gi;
			my $key = "$node1\t$node2";
			if(exists $edge_hash{$key}){
				$edge_hash{$key}++;
			}else{
				$edge_hash{$key} = 1;
			}
			$total_edges++;
		}
	}
}


#
# Iterate through each line
# where each line represents one food with multiple ingredients separated by (assumedly) a comma and or an "and'
#

my $foodcount = $#foods+1;
print "\nNow processing $foodcount foods found...\n";

#
# An empty array used later to build co-occurence
#
my @ing_arr;

my $count = 0;
foreach(@foods){
	# Get the current line
	my $currLine = $_;
	$count++;
	print "Now processing food $count of $foodcount\n";

	# Create variables for barcode and ingredients
	# Barcode should always be a positive int
	my $barcode = -1000;
	my $ingredients = "";

	# Split the line based on tabs (barcode <tab> ingredient list)
	my @tabs = split('\t',$currLine);

	if($tabs[0]){
		$barcode = $tabs[0];
	}else{
		print "No barcode found in $currLine\n";
	}
	
	#
	# Put the ingredients in a hash
	#
	if($tabs[1]){
		$ingredients = $tabs[1];
		
		#
		# Remove pesky items such as: newlines, replace "and" and "contains" with commas 
		# 
		$ingredients =~ s/\n//gi;
		$ingredients =~ s/\(/\,/gi;
		$ingredients =~ s/\)/\,/gi;
		$ingredients =~ s/ and /\,/gi;
		$ingredients =~ s/ contains /\,/gi;

		#
		# Separate ingredients by commas
		# 
		if($ingredients =~ m/\,/gi){
			my @items = split('\,',$ingredients);
			foreach(@items){
				my $curr_item = $_;
				$curr_item =~ s/^\s+|\s+$//gi;
				$curr_item =~ s/\(.*\)//gi;
				$curr_item =~ s/\(.*//gi;
				$curr_item =~ s/.*\)//gi;
				
				#
				# If curr item is empty space!
				#	
				if($curr_item =~ m/^\s+$/gi){
					# Sample print statement for debugging:
					# print "supposed to be blank:" . $curr_item . "\n";
					# Do nothing!	
				#
				# If curr_item is just one word!
				#
				}elsif($curr_item =~ m/^\s*(\w+)\s*$/gi){
					my $item = $1;
					push @ing_arr, $item;
				#
				# If curr_item contains and, with, or and should be a comma
				#	
				}elsif($curr_item =~ m/.*( and | with | or )+.*/gi){
					my $spliton = $1;
					my @items = split($spliton,$curr_item);
					foreach(@items){
						my $citem = $_;
						$citem =~ s/^\s+//gi;
						$citem =~ s/\s+$//gi;
						if($citem !~ m/^\s+$/gi){
							push @ing_arr, $citem;
						}else{
							die "Error: Unable to process this item: $citem\n";
						}	
					}
				
				#
				# If items are multiple words!
				#
				}elsif($curr_item =~ m/\s*([\S+\s+]+)\s*/gi){
					my $item = $1;
					push @ing_arr, $item;
				# 
				# If the current item is an empty string (I did this to myself)
				# Head nod to Bohemian on Stack Overflow for this one:
				# https://stackoverflow.com/questions/19127384/what-is-a-regex-to-match-only-an-empty-string
				#
				}elsif($curr_item =~ m/^(?![\s\S])/gi){
					# The item is empty but contains no space. Move on.
					# For example, if using the print statement:
					# die "Not catching current item -->$curr_item<--";
					# This will print "Not catching current item --><--"

				#
				# If the ingredients contain the words "and/or" like some sort of vague storyteller
				#
				}elsif($curr_item =~ m/(.*)and\/or(.*)/gi){
					my $item1 = $1;
					my $item2 = $2;
					push @ing_arr, $item1;
					push @ing_arr, $item2;
				}elsif($curr_item =~ m/(.*)and\/o(.*)/gi){
					my $item1 = $1;
					my $item2 = $2;
					push @ing_arr, $item1;
					push @ing_arr, $item2;

				#
				# If the current item contains an "'" but is NOT followed by an "s"
				# (If it is, it is probably a name and should be removed by the previous step in R)
				# If that happens, I just remove the apostrophe and pray the meaning is retained.
				#
				}elsif($curr_item =~ m/(.*)\'([^s].*)/gi){
					my $item = $1 . $2;		
					push @ing_arr, $item;

				#
				# If the current item contains an "'s" 
				# (It is probably a name and for whatever reason was not removed by the previous step in R)
				# If that happens, we remove the whole word ("M&M's" gets entirely removed)
				#
				}elsif($curr_item =~ m/^(.*)\s*\w+\'s(.*)\s*$/gi){
					my $item = $1 . $2;		
					push @ing_arr, $item;
				
				}else{
					die "Error: Unable to process this item: $curr_item\n";
				}
			}
		}else{
			#
			# Remove empty parentheses
			#
			$ingredients =~ s/\(.*\)//gi;
			$ingredients =~ s/\(//gi;
			$ingredients =~ s/\)//gi;	
			#
			# If ingredients are just empty space
			#
			if($ingredients =~ m/^\s+$/gi){
				#Do nothing!	
			
			#
			# If ingredients are just one word!
			#
			}elsif($ingredients =~ m/^\s*(\w+)\s*$/gi){
				my $item = $1;
				push @ing_arr, $item;

			# 
			# If ingredients contain and, with, or or
			#
			}elsif($ingredients =~ m/.*( and | with | or )+.*/gi){
				my $spliton = $1;
				my @items = split($spliton,$ingredients);
				foreach(@items){
					my $curr_item = $_;
					push @ing_arr, $curr_item;
				}

			# 
			# If ingredients contain multiple words
			#
			}elsif($ingredients =~ m/\s*([\S+\s+]+)\s*/gi){
				my $item = $1;
				push @ing_arr, $item;

			# 
			# If the current item is an empty string (I did this to myself)
			# Head nod to Bohemian on Stack Overflow for this one:
			# https://stackoverflow.com/questions/19127384/what-is-a-regex-to-match-only-an-empty-string
			#
			}elsif($ingredients =~ m/^(?![\s\S])/gi){
				# The item is empty but contains no space. Move on.
				# For example, if using the print statement:
				# die "Not catching current item -->$curr_item<--";
				# This will print "Not catching current item --><--"

			}else{
				die "Error: Unable to process this item: $ingredients\n";
			}
		}	
	}else{
		die "No ingredients found in $currLine\n";
	}
	
	if($#ing_arr+1 > 1){
		make_food_subnetwork(@ing_arr);
	}else{
		if($ing_arr[0]){
			print "$ing_arr[0] not added as it was the only ingredient listed for food $barcode\n";
			$single_ingredient_foods++;
		}
	}
	@ing_arr = ();
}

print "\nA total of $single_ingredient_foods single ingredient foods were found and are not represented in the network\n";

open(OUT,">$netfile");
while (my ($k,$v) = each %edge_hash){
	$k =~ s/\t/ /gi;
	print OUT "$k $v\n";
}
close OUT;

