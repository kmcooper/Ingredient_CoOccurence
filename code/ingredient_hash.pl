#####################################
# Script: 	ingredient_hash.pl
# Author: 	Kate Cooper
# Created: 	March 21, 2019
# Last edited:	April 4, 2019
# Input:	ingredients.tab file from ingredient network R code
# Output: 	an ingredient frequency (by count) from a hash
# Methods:	The purpose of this script is to create an ingredient hash from the Open Food Database
#		for the file generated from the Open Food Database
# Link:		Placeholder for code and raw data on Github
#####################################
#!/usr/bin/perl

use strict;
use warnings;

#
#Placeholder for the input file to be read from command line
#
my $inputfile = "";
my $out = "";

#
#Read in arguments from the command line; if no args, die. 
#
if($#ARGV+1 != 2){
	die "\nERROR! Check command-line arguments.\n
	Usage: perl ingredient_hash.pl ingredient_hash.tab hashfile.output \n
	ingredient_hash.tab 	= the file generated by the R script
	outfile.output 		= the name of the file you would like to write the food network written to
	\n\n"
}else{
	$inputfile = $ARGV[0];
	$out = $ARGV[1];
	print "Received the following file as input:		$inputfile\n";
	print "Received the following file for network output:	$out\n";
}

#
#Open the file and read it in
#
my $input = open(IN,$inputfile);
my @foods = <IN>;
close(IN)
	or warn "Error closing input file!\n";
#
# Create a hash and put all ingredients into it, counting how many times they occur
#
my %hash;
my $total_item_count = 0;

#
# Subroutine for when ready to add items to the hash
# Input: an ingredient (called an item or $i)
# Return: None
#
sub add_item{
	my $i = ($_[0]);
	$i =~ s/\n//gi;
	$i =~ s/^\s+|\s+$//gi;
	if(exists $hash{$i}){
		$hash{$i}++;
	}else{
		$hash{$i} = 1;
	}
}


#
# Iterate through each line
# where each line represents one food with multiple ingredients separated by (assumedly) a comma and or an "and'
#

my $foodcount = $#foods+1;
print "\nNow processing $foodcount foods found...\n";

foreach(@foods){
	# Get the current line
	my $currLine = $_;

	# Create variables for barcode and ingredients
	# Barcode should always be a positive int
	my $barcode = -1000;
	my $ingredients = "";

	# Split the line based on tabs (barcode <tab> ingredient list)
	my @tabs = split('\t',$currLine);

	if($tabs[0]){
		$barcode = $tabs[0];
	}else{
		print "No barcode found in $currLine\n";
	}
	
	#
	# Put the ingredients in a hash
	#
	if($tabs[1]){
		$ingredients = $tabs[1];
		
		#
		# Remove pesky items such as: newlines, replace "and" and "contains" with commas 
		# 
		$ingredients =~ s/\n//gi;
		$ingredients =~ s/\(/\,/gi;
		$ingredients =~ s/\)/\,/gi;
		$ingredients =~ s/ and /\,/gi;
		$ingredients =~ s/ contains /\,/gi;

		#
		# Separate ingredients by commas
		# 
		if($ingredients =~ m/\,/gi){
			my @items = split('\,',$ingredients);
			foreach(@items){
				my $curr_item = $_;
				$curr_item =~ s/^\s+|\s+$//gi;
				$curr_item =~ s/\(.*\)//gi;
				$curr_item =~ s/\(.*//gi;
				$curr_item =~ s/.*\)//gi;
				
				#
				# If curr item is empty space!
				#	
				if($curr_item =~ m/^\s+$/gi){
					# Sample print statement for debugging:
					# print "supposed to be blank:" . $curr_item . "\n";
					# Do nothing!	
				#
				# If curr_item is just one word!
				#
				}elsif($curr_item =~ m/^\s*(\w+)\s*$/gi){
					my $item = $1;
					add_item($item);
				#
				# If curr_item contains and, with, or and should be a comma
				#	
				}elsif($curr_item =~ m/.*( and | with | or )+.*/gi){
					my $spliton = $1;
					my @items = split($spliton,$curr_item);
					foreach(@items){
						my $citem = $_;
						$citem =~ s/^\s+//gi;
						$citem =~ s/\s+$//gi;
						if($citem !~ m/^\s+$/gi){
							add_item($citem);	
						}else{
							die "Error: Unable to process this item: $citem\n";
						}	
					}
				
				#
				# If items are multiple words!
				#
				}elsif($curr_item =~ m/\s*([\S+\s+]+)\s*/gi){
					my $item = $1;
					add_item($item);
				# 
				# If the current item is an empty string (I did this to myself)
				# Head nod to Bohemian on Stack Overflow for this one:
				# https://stackoverflow.com/questions/19127384/what-is-a-regex-to-match-only-an-empty-string
				#
				}elsif($curr_item =~ m/^(?![\s\S])/gi){
					# The item is empty but contains no space. Move on.
					# For example, if using the print statement:
					# die "Not catching current item -->$curr_item<--";
					# This will print "Not catching current item --><--"

				#
				# If the ingredients contain the words "and/or" like some sort of vague storyteller
				#
				}elsif($curr_item =~ m/(.*)and\/or(.*)/gi){
					my $item1 = $1;
					my $item2 = $2;
					add_item($item1);
					add_item($item2);
				}elsif($curr_item =~ m/(.*)and\/o(.*)/gi){
					my $item1 = $1;
					my $item2 = $2;
					add_item($item1);
					add_item($item2);

				#
				# If the current item contains an "'" but is NOT followed by an "s"
				# (If it is, it is probably a name and should be removed by the previous step in R)
				# If that happens, I just remove the apostrophe and pray the meaning is retained.
				#
				}elsif($curr_item =~ m/(.*)\'([^s].*)/gi){
					my $item = $1 . $2;		
					add_item($item);

				#
				# If the current item contains an "'s" 
				# (It is probably a name and for whatever reason was not removed by the previous step in R)
				# If that happens, we remove the whole word ("M&M's" gets entirely removed)
				#
				}elsif($curr_item =~ m/^(.*)\s*\w+\'s(.*)\s*$/gi){
					my $item = $1 . $2;		
					add_item($item);
				}else{
					die "Error: Unable to process this item: $curr_item\n";
				}
			}
		}else{
			#
			# Remove empty parentheses
			#
			$ingredients =~ s/\(.*\)//gi;
			$ingredients =~ s/\(//gi;
			$ingredients =~ s/\)//gi;	
			#
			# If ingredients are just empty space
			#
			if($ingredients =~ m/^\s+$/gi){
				#Do nothing!	
			
			#
			# If ingredients are just one word!
			#
			}elsif($ingredients =~ m/^\s*(\w+)\s*$/gi){
				my $item = $1;
				add_item($item);

			# 
			# If ingredients contain and, with, or or
			#
			}elsif($ingredients =~ m/.*( and | with | or )+.*/gi){
				my $spliton = $1;
				my @items = split($spliton,$ingredients);
				foreach(@items){
					my $curr_item = $_;
					add_item($curr_item);
				}

			# 
			# If ingredients contain multiple words
			#
			}elsif($ingredients =~ m/\s*([\S+\s+]+)\s*/gi){
				my $item = $1;
				add_item($item);

			# 
			# If the current item is an empty string (I did this to myself)
			# Head nod to Bohemian on Stack Overflow for this one:
			# https://stackoverflow.com/questions/19127384/what-is-a-regex-to-match-only-an-empty-string
			#
			}elsif($ingredients =~ m/^(?![\s\S])/gi){
				# The item is empty but contains no space. Move on.
				# For example, if using the print statement:
				# die "Not catching current item -->$curr_item<--";
				# This will print "Not catching current item --><--"

			}else{
				die "Error: Unable to process this item: $ingredients\n";
			}
		}	
	}else{
		die "No ingredients found in $currLine\n";
	}
}

#
# Sort the hash by values (smallest to largest)
#
my @keys = sort { $hash{$a} <=> $hash{$b} } keys(%hash);
my @vals = @hash{@keys};

#
# Print the hash
#
print "$#keys ingredients found total.\n";
print "Writing ingredient frequency hash to $out\n";
open(OUT,">$out");
foreach(@keys){
	my $k = $_;
	my $v = $hash{$k};
	print OUT "$k --> $v \n";
}
close OUT;
